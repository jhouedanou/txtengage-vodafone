import { ref, onUnmounted, nextTick } from 'vue';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';
import { ScrollToPlugin } from 'gsap/ScrollToPlugin';

gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

export function useFullpageScrollTrigger() {
  // ===========================================================================
  // SECTION 1: CONFIGURATION ET VARIABLES G√âN√âRALES
  // ===========================================================================
  
  // R√©f√©rences et √©tats globaux
  const sections = ref([]);
  const currentSectionIndex = ref(0);
  const isNavigating = ref(false);
  const hasScrolledOnce = ref(false);
  const animationStates = ref({});
  const isAnimating = ref(false);
  
  // Constantes
  const SCROLLER_SELECTOR = "#master-scroll-container";
  const sectionDuration = 1.2;
  const sectionEase = "power2.inOut";
  
  // AJOUTER CES VARIABLES MANQUANTES
  // NOUVELLES CONSTANTES AJOUT√âES
const tweenDuration = 0.4;
const tweenEase = "power3.easeInOut";
const slideEase = "power3.easeInOut";
const slideDuration = 0.7;
  // Variables internes de gestion
  let stObserve = null;
  const keyboardListener = ref(null);
  const specificAnimationTriggers = [];
  const slideSpecificEventListeners = [];

  // ===========================================================================
  // SECTION 2: FONCTIONS UTILITAIRES
  // ===========================================================================

  const goToSection = (index, duration = sectionDuration) => {
    if (index < 0 || index >= sections.value.length || isNavigating.value) return;

    console.log(`üöÄ Navigation vers section ${index}`);
    isNavigating.value = true;
    currentSectionIndex.value = index;

    const targetSection = sections.value[index];

    gsap.to(SCROLLER_SELECTOR, {
      scrollTo: { y: targetSection, autoKill: false },
      duration: duration,
      ease: sectionEase,
      onComplete: () => {
        console.log(`‚úÖ Navigation termin√©e vers section ${index}`);
        isNavigating.value = false;
        hasScrolledOnce.value = true;

        // D√©clencher les animations automatiques √† l'arriv√©e sur certaines slides
        if (targetSection.id === 'slide-20') {
          // Ne pas d√©clencher ici car c'est g√©r√© par ScrollTrigger
        } else if (targetSection.id === 'slide-21') {
          triggerSlide21Animation();
        } else if (targetSection.id === 'slide-22') {
          triggerSlide22Animation();
        } else if (targetSection.id === 'slide-23') {
          triggerSlide23Animation();
        }
      }
    });
  };

  // ===========================================================================
  // SECTION 3: GESTION DES √âV√âNEMENTS DE NAVIGATION
  // ===========================================================================

  const handleWheelEvent = (e) => {
    if (isNavigating.value) return;

    const currentSection = sections.value[currentSectionIndex.value];
    
    if (e.deltaY > 0) {
      // Scroll vers le bas
      
      // Gestion sp√©ciale pour slide-73
      if (currentSection && currentSection.id === 'slide-73') {
        if (!animationStates.value['slide-73-complete']) {
          triggerSlide73Animation();
          return;
        }
      }
      
      // Gestion sp√©ciale pour slide-20 (#text-element-5)
      if (currentSection && currentSection.id === 'slide-20') {
        // Si l'animation principale n'est pas termin√©e, bloquer compl√®tement
        if (!animationStates.value['slide-20-main-complete']) {
          return;
        }
        // Si l'animation principale est termin√©e mais text-element-5 pas encore affich√©
        if (!animationStates.value['slide-20-text-element-5']) {
          triggerSlide20TextElement5();
          return;
        }
        // Si tout est termin√©, permettre la navigation normale (continuer apr√®s ce if)
      }
      
      // Gestion sp√©ciale pour slide-23 (d√©filement des perdrix)
      if (currentSection && currentSection.id === 'slide-23') {
        if (animationStates.value['slide-23-initialized']) {
          const canScrollForward = scrollPerdrixForward();
          if (canScrollForward === false) {
            // Toutes les slides perdrix sont termin√©es, passer √† la slide suivante
            if (currentSectionIndex.value < sections.value.length - 1) {
              goToSection(currentSectionIndex.value + 1);
            }
          }
          return;
        }
      }
      
      // Gestion sp√©ciale pour slide-59
      if (currentSection && currentSection.id === 'slide-59') {
        if (!animationStates.value['slide-59-lass-shown']) {
          triggerSlide59Animation();
          return;
        }
        // Si l'animation est termin√©e, permettre la navigation normale
      }
      
      // Gestion sp√©ciale pour slide-128
      if (currentSection && currentSection.id === 'slide-128') {
        if (animationStates.value['slide-128-initialized']) {
          const canScrollForward = scrollSlide128Forward();
          if (canScrollForward === false) {
            // Tous les case-study-content sont termin√©s, passer √† la slide suivante
            if (currentSectionIndex.value < sections.value.length - 1) {
              goToSection(currentSectionIndex.value + 1);
            }
          }
          return;
        }
      }
      
      // Navigation normale vers la slide suivante
      if (currentSectionIndex.value < sections.value.length - 1) {
        goToSection(currentSectionIndex.value + 1);
      }
      
    } else {
      // Scroll vers le haut
      
      // Gestion sp√©ciale pour slide-73 - inverser l'animation
      if (currentSection && currentSection.id === 'slide-73') {
        if (animationStates.value['slide-73-complete'] && !animationStates.value['slide-73-reversing']) {
          reverseSlide73Animation();
          return;
        }
      }
      
      // Gestion sp√©ciale pour slide-23 (d√©filement des perdrix)
      if (currentSection && currentSection.id === 'slide-23') {
        if (animationStates.value['slide-23-initialized']) {
          // Si on est au d√©but des perdrix-slides, permettre la navigation vers la slide pr√©c√©dente
          if (perdrixScrollIndex <= 0) {
            if (currentSectionIndex.value > 0) {
              goToSection(currentSectionIndex.value - 1);
            }
            return;
          }
          // Sinon, continuer le d√©filement des perdrix vers l'arri√®re
          scrollPerdrixBackward();
          return;
        }
      }
      
      // Gestion sp√©ciale pour slide-128
      if (currentSection && currentSection.id === 'slide-128') {
        if (animationStates.value['slide-128-initialized']) {
          // Si on est au d√©but des case-study-content, permettre la navigation vers la slide pr√©c√©dente
          if (slide128CurrentIndex <= 0) {
            if (currentSectionIndex.value > 0) {
              goToSection(currentSectionIndex.value - 1);
            }
            return;
          }
          // Sinon, continuer le d√©filement des case-study-content vers l'arri√®re
          scrollSlide128Backward();
          return;
        }
      }
      
      // Navigation normale vers la slide pr√©c√©dente
      if (currentSectionIndex.value > 0) {
        goToSection(currentSectionIndex.value - 1);
      }
    }
  };

  const handleKeyboardNavigation = (e) => {
    if (isNavigating.value) return;

    const currentSection = sections.value[currentSectionIndex.value];

    switch(e.key) {
      case 'ArrowDown':
      case 'PageDown':
      case ' ': // Espace
        e.preventDefault();
        
        // Gestion sp√©ciale pour slide-73
        if (currentSection && currentSection.id === 'slide-73') {
          if (!animationStates.value['slide-73-complete']) {
            triggerSlide73Animation();
            return;
          }
        }
        
        // Gestion sp√©ciale pour slide-20 (#text-element-5)
        if (currentSection && currentSection.id === 'slide-20') {
          // Si l'animation principale n'est pas termin√©e, bloquer compl√®tement
          if (!animationStates.value['slide-20-main-complete']) {
            return;
          }
          // Si l'animation principale est termin√©e mais text-element-5 pas encore affich√©
          if (!animationStates.value['slide-20-text-element-5']) {
            triggerSlide20TextElement5();
            return;
          }
          // Si tout est termin√©, permettre la navigation normale (continuer apr√®s ce if)
        }
        
        // Gestion sp√©ciale pour slide-23 (d√©filement des perdrix)
        if (currentSection && currentSection.id === 'slide-23') {
          if (animationStates.value['slide-23-initialized']) {
            const canScrollForward = scrollPerdrixForward();
            if (canScrollForward === false) {
              // Toutes les slides perdrix sont termin√©es, passer √† la slide suivante
              if (currentSectionIndex.value < sections.value.length - 1) {
                goToSection(currentSectionIndex.value + 1);
              }
            }
            return;
          }
        }
        
        // Gestion sp√©ciale pour slide-59
        if (currentSection && currentSection.id === 'slide-59') {
          if (!animationStates.value['slide-59-lass-shown']) {
            triggerSlide59Animation();
            return;
          }
          // Si l'animation est termin√©e, permettre la navigation normale
        }
        
        // Gestion sp√©ciale pour slide-128
        if (currentSection && currentSection.id === 'slide-128') {
          if (animationStates.value['slide-128-initialized']) {
            scrollSlide128Forward();
            return;
          }
        }
        
        // Navigation normale vers la slide suivante
        if (currentSectionIndex.value < sections.value.length - 1) {
          goToSection(currentSectionIndex.value + 1);
        }
        break;
        
      case 'ArrowUp':
      case 'PageUp':
        e.preventDefault();
        
        // Gestion sp√©ciale pour slide-73 - inverser l'animation
        if (currentSection && currentSection.id === 'slide-73') {
          if (animationStates.value['slide-73-complete'] && !animationStates.value['slide-73-reversing']) {
            reverseSlide73Animation();
            return;
          }
        }
        
        // Gestion sp√©ciale pour slide-23 (d√©filement des perdrix)
        if (currentSection && currentSection.id === 'slide-23') {
          if (animationStates.value['slide-23-initialized']) {
            // Si on est au d√©but des perdrix-slides, permettre la navigation vers la slide pr√©c√©dente
            if (perdrixScrollIndex <= 0) {
              if (currentSectionIndex.value > 0) {
                goToSection(currentSectionIndex.value - 1);
              }
              return;
            }
            // Sinon, continuer le d√©filement des perdrix vers l'arri√®re
            scrollPerdrixBackward();
            return;
          }
        }
        
        // Gestion sp√©ciale pour slide-128
        if (currentSection && currentSection.id === 'slide-128') {
          if (animationStates.value['slide-128-initialized']) {
            scrollSlide128Backward();
            return;
          }
        }
        
        // Navigation normale vers la slide pr√©c√©dente
        if (currentSectionIndex.value > 0) {
          goToSection(currentSectionIndex.value - 1);
        }
        break;
        
      case 'Home':
        e.preventDefault();
        goToSection(0);
        break;
        
      case 'End':
        e.preventDefault();
        goToSection(sections.value.length - 1);
        break;
    }
  };

  // ===========================================================================
  // SECTION 4: ANIMATIONS SP√âCIFIQUES AUX SLIDES
  // ===========================================================================

// SLIDE-73 : Animation compl√®te des points forts avec fade des li
const registerSlide73Animation = () => {
  const slide73Section = sections.value.find(s => s.id === 'slide-73');
  if (!slide73Section) return;

  const slidesContainerDiv = slide73Section.querySelector('.slides-container');
  const pointsFortDiv = slide73Section.querySelector('.points-fort');
  const pointsFortLis = slide73Section.querySelectorAll('.points-fort li');

  if (slidesContainerDiv && pointsFortDiv) {
    // √âtat initial
    gsap.set(slidesContainerDiv, {
      opacity: 1,
      visibility: 'inherit',
      height: '100vh',
      width: '100vw',
      backgroundSize:'120vw',
      backgroundPositionX: '0vw', // Position initiale explicite
      backgroundRepeat: 'no-repeat',
    });
    
    gsap.set(pointsFortDiv, {
      opacity: 1,
      visibility: 'inherit',
      height: '100vh',
      width: '0vw',
      x: '100vw' // Commence compl√®tement hors du champ √† droite
    });

    // Cacher initialement tous les li
    if (pointsFortLis.length > 0) {
      gsap.set(pointsFortLis, {
        autoAlpha: 0,
        y: 30
      });
    }
  }

  const st = ScrollTrigger.create({
    trigger: slide73Section,
    scroller: SCROLLER_SELECTOR,
    start: 'top center+=10%',
    onEnter: () => {
      // Pas d'animation automatique, attendre le scroll
    },
    onLeave: () => {
      // Conserver l'√©tat final quand on descend
    },
    onEnterBack: () => {
      // Conserver l'√©tat actuel et permettre le contr√¥le par scroll
      // Ne pas r√©initialiser automatiquement
      console.log('Slide-73: Retour du bas, √©tat conserv√© pour contr√¥le scroll');
    },
    onLeaveBack: () => {
      // R√©initialiser seulement quand on quitte vers le haut
      resetSlide73Animation();
    }
  });

  specificAnimationTriggers.push(st);
};

const triggerSlide73Animation = () => {
  if (animationStates.value['slide-73-complete']) return;
  
  const slide73Section = sections.value.find(s => s.id === 'slide-73');
  const slidesContainerDiv = slide73Section?.querySelector('.slides-container');
  const pointsFortDiv = slide73Section?.querySelector('.points-fort');
  const pointsFortLis = slide73Section?.querySelectorAll('.points-fort li');
  
  if (!slidesContainerDiv || !pointsFortDiv) return;

  animationStates.value['slide-73-animating'] = true;
  isNavigating.value = true;

  const tl = gsap.timeline({
    onComplete: () => {
      animationStates.value['slide-73-complete'] = true;
      animationStates.value['slide-73-animating'] = false;
      isNavigating.value = false;
      console.log('Slide-73: Animation termin√©e');
    }
  });

  // Phase 1: Faire entrer points-fort √† moiti√© dans le champ
  tl.to(pointsFortDiv, {
    width: '50vw', // Prends la moiti√© de la largeur
    x: 0, // Entre √† moiti√© dans le champ
    duration: 0.5,
    ease: 'power3.easeInOut'
  })
  .to(slidesContainerDiv, {
    backgroundPositionX: '-20vw', // D√©place le background de -50vw
    duration: 0.5,
    ease: 'power3.easeInOut'
  }, "<"); // "<" pour d√©marrer en m√™me temps
  // Phase 2: Faire appara√Ætre les li en cascade avec un d√©lai
  if (pointsFortLis.length > 0) {
    tl.to(pointsFortLis, {
      autoAlpha: 1,
      y: 0,
      duration: 0.4,
      stagger: 0.1, // D√©lai entre chaque li
      ease: 'power2.out'
    }, "+=0.3"); // D√©lai de 0.3s apr√®s l'entr√©e du container
  }
};

// Nouvelle fonction pour inverser l'animation slide-73
const reverseSlide73Animation = () => {
  if (!animationStates.value['slide-73-complete']) return;
  
  const slide73Section = sections.value.find(s => s.id === 'slide-73');
  const slidesContainerDiv = slide73Section?.querySelector('.slides-container');
  const pointsFortDiv = slide73Section?.querySelector('.points-fort');
  const pointsFortLis = slide73Section?.querySelectorAll('.points-fort li');
  
  if (!slidesContainerDiv || !pointsFortDiv) return;

  animationStates.value['slide-73-reversing'] = true;
  isNavigating.value = true;

  const tl = gsap.timeline({
    onComplete: () => {
      animationStates.value['slide-73-complete'] = false;
      animationStates.value['slide-73-reversing'] = false;
      isNavigating.value = false;
      console.log('Slide-73: Animation invers√©e termin√©e');
    }
  });

  // Phase 1: Masquer les li d'abord
  if (pointsFortLis.length > 0) {
    tl.to(pointsFortLis, {
      autoAlpha: 0,
      y: 30,
      duration: 0.3,
      stagger: -0.05, // Stagger invers√© (dernier en premier)
      ease: 'power2.in'
    });
  }

  // Phase 2: Faire sortir points-fort et remettre background en place
  tl.to(pointsFortDiv, {
    width: '0vw',
    x: '100vw', // Sort compl√®tement du champ
    duration: 0.5,
    ease: 'power3.easeInOut'
  }, "+=0.2")
  .to(slidesContainerDiv, {
    backgroundPositionX: '0vw', // Remet le background √† sa position initiale
    duration: 0.5,
    ease: 'power3.easeInOut'
  }, "<"); // En parall√®le
};

// Mise √† jour du resetSlide73Animation pour r√©initialiser le background seulement sur slide-21
const resetSlide73Animation = () => {
  const slide73Section = sections.value.find(s => s.id === 'slide-73');
  const slidesContainerDiv = slide73Section?.querySelector('.slides-container');
  const pointsFortDiv = slide73Section?.querySelector('.points-fort');
  const pointsFortLis = slide73Section?.querySelectorAll('.points-fort li');
  
  if (slidesContainerDiv && pointsFortDiv) {
    // Ne plus r√©initialiser le background - conserver la position -20vw
    
    // Remettre points-fort hors du champ (toujours)
    gsap.set(pointsFortDiv, {
      width: '0vw',
      x: '100vw'
    });

    // Cacher √† nouveau tous les li (toujours)
    if (pointsFortLis.length > 0) {
      gsap.set(pointsFortLis, {
        autoAlpha: 0,
        y: 30
      });
    }
  }
  
  animationStates.value['slide-73-complete'] = false;
  animationStates.value['slide-73-animating'] = false;
  animationStates.value['slide-73-reversing'] = false;
};

  // SLIDE-21 : Faire appara√Ætre le texte une fois la slide visible
  const triggerSlide21Animation = () => {
    if (animationStates.value['slide-21-complete']) return;
    
    const slide21Section = sections.value.find(s => s.id === 'slide-21');
    const thoiathoing = slide21Section?.querySelector('#thoiathoing');
    
    if (thoiathoing) {
      isNavigating.value = true;
      gsap.to(thoiathoing, {
        autoAlpha: 1,
        y: 0,
        duration: 0.8,
        ease: "power2.out",
        onComplete: () => {
          animationStates.value['slide-21-complete'] = true;
          isNavigating.value = false;
        }
      });
    }
  };

  // SLIDE-20 : Animation de #turtlebeach puis √©l√©ments apparaissent les uns apr√®s les autres
  const registerSlide20Animation = () => {
    const slide20Section = sections.value.find(s => s.id === 'slide-20');
    if (!slide20Section) return;

    const turtlebeach = slide20Section.querySelector('#turtlebeach');
    const textElements = slide20Section.querySelectorAll('.text-element:not(#text-element-5)');
    const textElement5 = slide20Section.querySelector('#text-element-5');

    // √âtat initial avec les param√®tres de r√©f√©rence
    if (turtlebeach) {
      gsap.set(turtlebeach, { 
        autoAlpha: 0, 
        scale: 0.8,
        y: 50,
        rotation: -5
      });
    }

    if (textElements.length > 0) {
      gsap.set(textElements, { 
        autoAlpha: 0, 
        y: 100
      });
    }
    if (textElement5) {
      gsap.set(textElement5, { 
        autoAlpha: 0, 
        y: 100
      });
    }

    const st = ScrollTrigger.create({
      trigger: slide20Section,
      scroller: SCROLLER_SELECTOR,
      start: 'top center+=10%',
      onEnter: () => {
        // Bloquer imm√©diatement la navigation d√®s l'entr√©e
        isNavigating.value = true;
        // D√©clencher l'animation automatique d'entr√©e
        triggerSlide20Animation();
      },
      onEnterBack: () => {
        // Bloquer imm√©diatement la navigation
        isNavigating.value = true;
        // R√©initialiser compl√®tement quand on revient du bas
        resetSlide20Animation();
        // Puis relancer l'animation apr√®s un d√©lai
        setTimeout(() => {
          triggerSlide20Animation();
        }, 100);
      },
      onLeaveBack: () => {
        // R√©initialiser quand on quitte vers le haut
        resetSlide20Animation();
      },
      onLeave: () => {
        // R√©initialiser aussi quand on quitte vers le bas pour √©viter les conflits
        resetSlide20Animation();
      }
    });

    specificAnimationTriggers.push(st);
  };

  const triggerSlide20Animation = () => {
    if (animationStates.value['slide-20-main-complete']) return;
    
    const slide20Section = sections.value.find(s => s.id === 'slide-20');
    const turtlebeach = slide20Section?.querySelector('#turtlebeach');
    const textElements = slide20Section?.querySelectorAll('.text-element:not(#text-element-5)');
    
    if (!turtlebeach) {
      // Si pas d'√©l√©ment trouv√©, d√©bloquer la navigation
      isNavigating.value = false;
      return;
    }

    // S'assurer que la navigation est bloqu√©e (pourrait d√©j√† l'√™tre depuis ScrollTrigger)
    animationStates.value['slide-20-animating'] = true;
    isNavigating.value = true;

    const tl = gsap.timeline({
      onComplete: () => {
        animationStates.value['slide-20-main-complete'] = true;
        animationStates.value['slide-20-animating'] = false;
        isNavigating.value = false;
        console.log('Slide-20: Animation principale termin√©e');
      }
    });

    // Phase 1: Animation de #turtlebeach en premier
    tl.to(turtlebeach, {
      autoAlpha: 1,
      scale: 1,
      y: 0,
      rotation: 0,
      duration: 0.8,
      ease: 'back.out(1.7)'
    });

    // Phase 2: Animation des √©l√©ments texte apr√®s turtlebeach
    if (textElements && textElements.length > 0) {
      tl.to(textElements, {
        autoAlpha: 1,
        y: 0,
        duration: tweenDuration,
        stagger: 0.15, // D√©lai entre chaque √©l√©ment
        ease: tweenEase
      }, "+=0.3"); // D√©lai de 0.3s apr√®s turtlebeach
    }
  };

  const triggerSlide20TextElement5 = () => {
    if (animationStates.value['slide-20-text-element-5']) return;
    
    const slide20Section = sections.value.find(s => s.id === 'slide-20');
    const textElement5 = slide20Section?.querySelector('#text-element-5');
    
    if (textElement5) {
      isNavigating.value = true;
      gsap.to(textElement5, {
        autoAlpha: 1,
        y: 0,
        duration: tweenDuration, // ‚Üê Maintenant d√©finie
        ease: tweenEase, // ‚Üê Maintenant d√©finie
        onComplete: () => {
          animationStates.value['slide-20-text-element-5'] = true;
          isNavigating.value = false;
        }
      });
    }
  };

  const resetSlide20Animation = () => {
    const slide20Section = sections.value.find(s => s.id === 'slide-20');
    const turtlebeach = slide20Section?.querySelector('#turtlebeach');
    const textElements = slide20Section?.querySelectorAll('.text-element');
    
    // R√©initialiser #turtlebeach
    if (turtlebeach) {
      gsap.set(turtlebeach, { 
        autoAlpha: 0, 
        scale: 0.8,
        y: 50,
        rotation: -5
      });
    }

    // R√©initialiser tous les √©l√©ments texte
    if (textElements) {
      gsap.set(textElements, { 
        autoAlpha: 0, 
        y: 100
      });
    }
    
    // Reset des √©tats
    animationStates.value['slide-20-main-complete'] = false;
    animationStates.value['slide-20-text-element-5'] = false;
    animationStates.value['slide-20-animating'] = false;
  };

  // SLIDE-22 : Faire appara√Ætre le texte une fois la slide visible
  const triggerSlide22Animation = () => {
    if (animationStates.value['slide-22-complete']) return;
    
    const slide22Section = sections.value.find(s => s.id === 'slide-22');
    const textContent = slide22Section?.querySelector('.text-element, .content');
    
    if (textContent) {
      isNavigating.value = true;
      gsap.to(textContent, {
        autoAlpha: 1,
        y: 0,
        duration: 0.8,
        ease: "power2.out",
        onComplete: () => {
          animationStates.value['slide-22-complete'] = true;
          isNavigating.value = false;
        }
      });
    }
  };

  // SLIDE-23 : Afficher #perdrix-slide-1 et g√©rer le d√©filement avec synchronisation des image-containers
  const registerSlide23Animation = () => {
    const slide23Section = sections.value.find(s => s.id === 'slide-23');
    if (!slide23Section) return;

    // Chercher les √©l√©ments essentiels
    const perdrixContainer = slide23Section.querySelector('#perdrix-container, #bygone-bip');
    const perdrixSlides = slide23Section.querySelectorAll('.perdrix-slide');
    const firstPerdrixSlide = slide23Section.querySelector('#perdrix-slide-1');
    const imageContainers = slide23Section.querySelectorAll('.image-container');

    console.log('Slide-23 Register Advanced:', {
      slide23Section: !!slide23Section,
      perdrixContainer: !!perdrixContainer,
      perdrixSlidesCount: perdrixSlides.length,
      firstPerdrixSlide: !!firstPerdrixSlide,
      imageContainersCount: imageContainers.length
    });

    // √âtat initial - masquer le conteneur et pr√©parer les slides
    if (perdrixContainer) {
      gsap.set(perdrixContainer, { autoAlpha: 1 });
    }
    
    // Initialiser tous les perdrix-slides - masqu√©s sauf le premier
    if (perdrixSlides.length > 0) {
      perdrixSlides.forEach((slide, index) => {
        const textContainer = slide.querySelector('.text-container');
        
        if (index === 0) {
          // Premier slide : visible
          gsap.set(slide, { autoAlpha: 1 });
          if (textContainer) gsap.set(textContainer, { y: 0 });
        } else {
          // Autres slides : masqu√©s et positionn√©s
          gsap.set(slide, { autoAlpha: 0 });
          if (textContainer) gsap.set(textContainer, { y: '100vh', autoAlpha: 0 });
        }
      });
    }

    // Initialiser tous les image-containers - masqu√©s sauf le premier
    if (imageContainers.length > 0) {
      imageContainers.forEach((container, index) => {
        if (index === 0) {
          // Premier container : visible
          gsap.set(container, { autoAlpha: 1, y: 0 });
        } else {
          // Autres containers : positionn√©s hors du viewport mais visibles
          gsap.set(container, { autoAlpha: 1, y: '504px' });
        }
      });
    }

    const st = ScrollTrigger.create({
      trigger: slide23Section,
      scroller: SCROLLER_SELECTOR,
      start: 'top center+=10%',
      onEnter: () => {
        triggerSlide23Animation();
      },
      onEnterBack: () => {
        triggerSlide23Animation();
      },
      onLeave: () => {
        // Maintenir l'√©tat en quittant
      },
      onLeaveBack: () => {
        resetSlide23Animation();
      }
    });

    specificAnimationTriggers.push(st);
  };

  const triggerSlide23Animation = () => {
    if (animationStates.value['slide-23-initialized']) return;
    
    const slide23Section = sections.value.find(s => s.id === 'slide-23');
    const perdrixContainer = slide23Section?.querySelector('#perdrix-container, #bygone-bip');
    const firstPerdrixSlide = slide23Section?.querySelector('#perdrix-slide-1');
    const firstImageContainer = slide23Section?.querySelector('#image-container-1');
    
    console.log('D√©marrage animation slide-23 avanc√©e');
    
    if (perdrixContainer) {
      // Afficher le conteneur et le premier slide
      gsap.to(perdrixContainer, {
        autoAlpha: 1,
        duration: 0.5,
        ease: "power2.out",
        onComplete: () => {
          // S'assurer que le premier slide et la premi√®re image sont visibles
          if (firstPerdrixSlide) {
            gsap.set(firstPerdrixSlide, { autoAlpha: 1 });
          }
          if (firstImageContainer) {
            gsap.set(firstImageContainer, { autoAlpha: 1, y: 0 });
          }
          
          animationStates.value['slide-23-initialized'] = true;
          animationStates.value['slide-23-current-index'] = 0;
          console.log('Slide-23 initialis√©e - Premier slide et premi√®re image affich√©s');
        }
      });
    } else {
      console.error('Slide-23: Container not found');
      animationStates.value['slide-23-initialized'] = true;
    }
  };

  // Variables pour le d√©filement perdrix
  let perdrixScrollIndex = 0;
  let maxPerdrixScroll = 0; // Sera calcul√© dynamiquement
  let isScrollingPerdrix = false;

  const initializePerdrixScrollLimits = () => {
    const slide23Section = sections.value.find(s => s.id === 'slide-23');
    const perdrixSlides = slide23Section?.querySelectorAll('.perdrix-slide');
    const imageContainers = slide23Section?.querySelectorAll('.image-container');
    // Prendre le maximum entre perdrix slides et image containers
    const perdrixCount = perdrixSlides ? perdrixSlides.length : 0;
    const imageCount = imageContainers ? imageContainers.length : 0;
    maxPerdrixScroll = Math.max(perdrixCount, imageCount) - 1;
    console.log(`Perdrix scroll limites: max = ${maxPerdrixScroll} (perdrix: ${perdrixCount}, images: ${imageCount})`);
  };

  const scrollPerdrixForward = () => {
    if (isScrollingPerdrix) return;
    
    // Initialiser les limites si pas encore fait
    if (maxPerdrixScroll === 0) {
      initializePerdrixScrollLimits();
    }
    
    // Si on a atteint la fin, permettre la navigation vers la slide suivante
    if (perdrixScrollIndex >= maxPerdrixScroll) {
      console.log('Fin des slides perdrix atteinte, navigation vers slide suivante');
      isNavigating.value = false; // D√©bloquer la navigation
      return false; // Indiquer qu'on peut passer √† la slide suivante
    }
    
    isScrollingPerdrix = true;
    isNavigating.value = true;
    
    const slide23Section = sections.value.find(s => s.id === 'slide-23');
    const currentSlide = slide23Section?.querySelector(`#perdrix-slide-${perdrixScrollIndex + 1}`);
    const nextSlide = slide23Section?.querySelector(`#perdrix-slide-${perdrixScrollIndex + 2}`);
    const currentImageContainer = slide23Section?.querySelector(`#image-container-${perdrixScrollIndex + 1}`);
    const nextImageContainer = slide23Section?.querySelector(`#image-container-${perdrixScrollIndex + 2}`);
    
    console.log(`D√©filement perdrix avant: ${perdrixScrollIndex} -> ${perdrixScrollIndex + 1}`);
    
    const tl = gsap.timeline({
      onComplete: () => {
        perdrixScrollIndex++;
        animationStates.value['slide-23-current-index'] = perdrixScrollIndex;
        isScrollingPerdrix = false;
        isNavigating.value = false;
        console.log(`D√©filement termin√© - nouvel index: ${perdrixScrollIndex}`);
      }
    });

    // Animation des perdrix-slides sans fade
    if (currentSlide && nextSlide) {
      const currentTextContainer = currentSlide.querySelector('.text-container');
      const nextTextContainer = nextSlide.querySelector('.text-container');
      
      // Pr√©parer le slide suivant
      gsap.set(nextSlide, { autoAlpha: 1 });
      if (nextTextContainer) {
        gsap.set(nextTextContainer, { y: '100vh', autoAlpha: 0 });
      }
      
      // Animation simultan√©e des text-containers
      if (currentTextContainer) {
        tl.to(currentTextContainer, {
          y: '-100vh',
          autoAlpha: 1,
          duration: 0.4,
          ease: 'power3.easeInOut'
        }, 0);
      }
      
      if (nextTextContainer) {
        tl.to(nextTextContainer, {
          y: 0,
          autoAlpha: 1,
          duration: 0.4,
          ease: 'power3.easeInOut'
        }, 0);
      }
      
      // Masquer le slide actuel apr√®s l'animation
      tl.to(currentSlide, {
        autoAlpha: 1,
        duration: 0.1,
        ease: 'power3.out'
      }, 0.4);
    }

    // Animation synchronis√©e des image-containers sans fade
    if (currentImageContainer && nextImageContainer) {
      // Pr√©parer le container suivant
      gsap.set(nextImageContainer, { autoAlpha: 1, y: '504px' });
      
      // Animation simultan√©e des image-containers - l'ancienne reste visible
      tl.to(currentImageContainer, {
        y: '-504px',
        duration: 0.4,
        ease: 'power3.easeInOut'
      }, 0);
      
      tl.to(nextImageContainer, {
        y: 0,
        duration: 0.4,
        ease: 'power3.easeInOut'
      }, 0);
    }

    return true; // Indiquer que l'animation a √©t√© lanc√©e
  };

  const scrollPerdrixBackward = () => {
    if (isScrollingPerdrix || perdrixScrollIndex <= 0) return;
    
    isScrollingPerdrix = true;
    isNavigating.value = true;
    
    const slide23Section = sections.value.find(s => s.id === 'slide-23');
    const currentSlide = slide23Section?.querySelector(`#perdrix-slide-${perdrixScrollIndex + 1}`);
    const prevSlide = slide23Section?.querySelector(`#perdrix-slide-${perdrixScrollIndex}`);
    const currentImageContainer = slide23Section?.querySelector(`#image-container-${perdrixScrollIndex + 1}`);
    const prevImageContainer = slide23Section?.querySelector(`#image-container-${perdrixScrollIndex}`);
    
    console.log(`D√©filement perdrix arri√®re: ${perdrixScrollIndex} -> ${perdrixScrollIndex - 1}`);
    
    const tl = gsap.timeline({
      onComplete: () => {
        perdrixScrollIndex--;
        animationStates.value['slide-23-current-index'] = perdrixScrollIndex;
        isScrollingPerdrix = false;
        isNavigating.value = false;
        console.log(`D√©filement arri√®re termin√© - nouvel index: ${perdrixScrollIndex}`);
      }
    });

    // Animation des perdrix-slides sans fade
    if (currentSlide && prevSlide) {
      const currentTextContainer = currentSlide.querySelector('.text-container');
      const prevTextContainer = prevSlide.querySelector('.text-container');
      
      // Pr√©parer le slide pr√©c√©dent
      gsap.set(prevSlide, { autoAlpha: 1 });
      if (prevTextContainer) {
        gsap.set(prevTextContainer, { y: '-100vh', autoAlpha: 0 });
      }
      
      // Animation simultan√©e des text-containers
      if (currentTextContainer) {
        tl.to(currentTextContainer, {
          y: '100vh',
          autoAlpha: 1,
          duration: 0.4,
          ease: 'power3.easeInOut'
        }, 0);
      }
      
      if (prevTextContainer) {
        tl.to(prevTextContainer, {
          y: 0,
          autoAlpha: 1,
          duration: 0.4,
          ease: 'power3.easeInOut'
        }, 0);
      }
      
      // Masquer le slide actuel apr√®s l'animation
      tl.to(currentSlide, {
        autoAlpha: 0,
        duration: 0.1,
        ease: 'power3.out'
      }, 0.4);
    }

    // Animation synchronis√©e des image-containers sans fade
    if (currentImageContainer && prevImageContainer) {
      // Pr√©parer le container pr√©c√©dent
      gsap.set(prevImageContainer, { autoAlpha: 1, y: '-504px' });
      
      // Animation simultan√©e des image-containers - l'ancienne reste visible
      tl.to(currentImageContainer, {
        y: '504px',
        duration: 0.4,
        ease: 'power3.easeInOut'
      }, 0);
      
      tl.to(prevImageContainer, {
        y: 0,
        duration: 0.4,
        ease: 'power3.easeInOut'
      }, 0);
    }
  };

  const resetSlide23Animation = () => {
    const slide23Section = sections.value.find(s => s.id === 'slide-23');
    const perdrixContainer = slide23Section?.querySelector('#perdrix-container, #bygone-bip');
    const perdrixSlides = slide23Section?.querySelectorAll('.perdrix-slide');
    const imageContainers = slide23Section?.querySelectorAll('.image-container');
    
    console.log('Reset slide-23 animation');
    
    if (perdrixContainer) {
      gsap.set(perdrixContainer, { autoAlpha: 0 });
    }
    
    if (perdrixSlides) {
      perdrixSlides.forEach((slide, index) => {
        const textContainer = slide.querySelector('.text-container');
        
        if (index === 0) {
          // Premier slide : pr√™t pour r√©initialisation
          gsap.set(slide, { autoAlpha: 1 });
          if (textContainer) gsap.set(textContainer, { y: 0 });
        } else {
          // Autres slides : masqu√©s
          gsap.set(slide, { autoAlpha: 0 });
          if (textContainer) gsap.set(textContainer, { y: '100vh', autoAlpha: 0 });
        }
      });
    }

    // R√©initialiser les image-containers
    if (imageContainers) {
      imageContainers.forEach((container, index) => {
        if (index === 0) {
          // Premier container : pr√™t pour r√©initialisation
          gsap.set(container, { autoAlpha: 1, y: 0 });
        } else {
          // Autres containers : positionn√©s hors du viewport mais visibles
          gsap.set(container, { autoAlpha: 1, y: '504px' });
        }
      });
    }
    
    // Reset des variables
    perdrixScrollIndex = 0;
    maxPerdrixScroll = 0;
    isScrollingPerdrix = false;
    animationStates.value['slide-23-initialized'] = false;
    animationStates.value['slide-23-current-index'] = 0;
  };

  // SLIDE-59 : Afficher #llass avec effet de remplissage et gestion de navigation
  const registerSlide59Animation = () => {
    const slide59Section = sections.value.find(s => s.id === 'slide-59');
    if (!slide59Section) return;

    const llassDiv = slide59Section.querySelector('#llass');
    const leleDiv = slide59Section.querySelector('#lele');

    // √âtat initial
    if (llassDiv) {
      gsap.set(llassDiv, { 
        autoAlpha: 1, // Visible mais masqu√© par clip-path
        clipPath: 'inset(0 0 0 100%)', // Masqu√© compl√®tement depuis la gauche
        transformOrigin: 'center left'
      });
    }
    if (leleDiv) {
      gsap.set(leleDiv, { 
        autoAlpha: 1
      });
    }

    const st = ScrollTrigger.create({
      trigger: slide59Section,
      scroller: SCROLLER_SELECTOR,
      start: 'top center+=10%',
      onEnter: () => {
        // Animation automatique √† l'entr√©e
        triggerSlide59Animation();
      },
      onEnterBack: () => {
        // R√©initialiser et rejouer l'animation
        resetSlide59Animation();
        setTimeout(() => {
          triggerSlide59Animation();
        }, 100);
      },
      onLeaveBack: () => {
        // R√©initialiser quand on quitte vers le haut
        resetSlide59Animation();
      },
      onLeave: () => {
        // Maintenir l'√©tat quand on descend
      }
    });

    specificAnimationTriggers.push(st);
  };

  const triggerSlide59Animation = () => {
    if (animationStates.value['slide-59-lass-shown']) return;
    
    const slide59Section = sections.value.find(s => s.id === 'slide-59');
    const llassDiv = slide59Section?.querySelector('#llass');
    
    if (llassDiv) {
      isNavigating.value = true;
      
      // Animation avec effet de remplissage des barres rouges de gauche √† droite
      gsap.to(llassDiv, {
        clipPath: 'inset(0 0 0 0%)', // R√©v√®le compl√®tement l'image de gauche √† droite
        duration: 1.5, // Plus long pour voir le remplissage
        ease: "power2.out", // Effet fluide pour le remplissage
        onComplete: () => {
          animationStates.value['slide-59-lass-shown'] = true;
          isNavigating.value = false;
          console.log('Slide-59: Animation de remplissage #llass (gauche‚Üídroite) termin√©e');
        }
      });
    }
  };

  const resetSlide59Animation = () => {
    const slide59Section = sections.value.find(s => s.id === 'slide-59');
    const llassDiv = slide59Section?.querySelector('#llass');
    const leleDiv = slide59Section?.querySelector('#lele');
    
    if (llassDiv) {
      gsap.set(llassDiv, { 
        autoAlpha: 1, // Visible mais masqu√© par clip-path
        clipPath: 'inset(0 0 0 100%)', // Masqu√© compl√®tement depuis la gauche
        transformOrigin: 'center left'
      });
    }
    if (leleDiv) {
      gsap.set(leleDiv, { autoAlpha: 1 });
    }
    
    animationStates.value['slide-59-lass-shown'] = false;
    console.log('Slide-59: Animation reset');
  };

  // SLIDE-128 : Afficher #killerwu et cycler entre les case-study-content
  const registerSlide128Animation = () => {
    const slide128Section = sections.value.find(s => s.id === 'slide-128');
    if (!slide128Section) return;

    const killerwuDiv = slide128Section.querySelector('#killerwu');
    const caseStudyItems = slide128Section.querySelectorAll('.case-study-item');
    const caseStudyContents = slide128Section.querySelectorAll('.case-study-content');

    // √âtat initial
    if (killerwuDiv) {
      gsap.set(killerwuDiv, { autoAlpha: 0 });
    }
    
    // Initialiser tous les case-study-content - masqu√©s sauf le premier
    if (caseStudyContents.length > 0) {
      caseStudyContents.forEach((content, index) => {
        const parentItem = content.closest('.case-study-item');
        if (index === 0) {
          // Premier content : visible avec classe active
          gsap.set(content, { autoAlpha: 1, y: 0 });
          if (parentItem) parentItem.classList.add('active');
        } else {
          // Autres contents : masqu√©s
          gsap.set(content, { autoAlpha: 0, y: 30 });
          if (parentItem) parentItem.classList.remove('active');
        }
      });
    }

    const st = ScrollTrigger.create({
      trigger: slide128Section,
      scroller: SCROLLER_SELECTOR,
      start: 'top center+=10%',
      onEnter: () => {
        triggerSlide128Animation();
      },
      onEnterBack: () => {
        triggerSlide128Animation();
      },
      onLeaveBack: () => {
        resetSlide128Animation();
      },
      onLeave: () => {
        // Maintenir l'√©tat en quittant
      }
    });

    specificAnimationTriggers.push(st);
  };

  const triggerSlide128Animation = () => {
    if (animationStates.value['slide-128-initialized']) return;
    
    const slide128Section = sections.value.find(s => s.id === 'slide-128');
    const killerwuDiv = slide128Section?.querySelector('#killerwu');
    const firstCaseStudyContent = slide128Section?.querySelector('.case-study-content:first-of-type');
    const firstCaseStudyItem = slide128Section?.querySelector('.case-study-item:first-of-type');
    
    isNavigating.value = true;
    
    const tl = gsap.timeline({
      onComplete: () => {
        animationStates.value['slide-128-initialized'] = true;
        animationStates.value['slide-128-current-index'] = 0;
        isNavigating.value = false;
        console.log('Slide-128: Animation initiale termin√©e - Premier content affich√©');
      }
    });

    if (killerwuDiv) {
      tl.to(killerwuDiv, {
        autoAlpha: 1,
        duration: 0.8,
        ease: "power2.out"
      });
    }

    if (firstCaseStudyContent) {
      // S'assurer que le premier content est visible et actif
      gsap.set(firstCaseStudyContent, { autoAlpha: 1, y: 0 });
      if (firstCaseStudyItem) {
        firstCaseStudyItem.classList.add('active');
      }
      
      tl.to(firstCaseStudyContent, {
        autoAlpha: 1,
        y: 0,
        duration: 0.6,
        ease: "power2.out"
      }, "-=0.3");
    }
  };

  let slide128CurrentIndex = 0;
  let maxSlide128Index = 0; // Sera calcul√© dynamiquement
  let isScrollingSlide128 = false;

  const initializeSlide128ScrollLimits = () => {
    const slide128Section = sections.value.find(s => s.id === 'slide-128');
    const caseStudyContents = slide128Section?.querySelectorAll('.case-study-content');
    maxSlide128Index = caseStudyContents ? caseStudyContents.length - 1 : 0;
    console.log(`Slide-128 scroll limites: max = ${maxSlide128Index}`);
  };

  const scrollSlide128Forward = () => {
    if (isScrollingSlide128) return;
    
    // Initialiser les limites si pas encore fait
    if (maxSlide128Index === 0) {
      initializeSlide128ScrollLimits();
    }
    
    // Si on a atteint la fin, permettre la navigation vers la slide suivante
    if (slide128CurrentIndex >= maxSlide128Index) {
      console.log('Fin des case-study-content atteinte, navigation vers slide suivante');
      isNavigating.value = false; // D√©bloquer la navigation
      return false; // Indiquer qu'on peut passer √† la slide suivante
    }
    
    isScrollingSlide128 = true;
    isNavigating.value = true;
    
    const slide128Section = sections.value.find(s => s.id === 'slide-128');
    const currentContent = slide128Section?.querySelector(`.case-study-content:nth-of-type(${slide128CurrentIndex + 1})`);
    const nextContent = slide128Section?.querySelector(`.case-study-content:nth-of-type(${slide128CurrentIndex + 2})`);
    const currentItem = currentContent?.closest('.case-study-item');
    const nextItem = nextContent?.closest('.case-study-item');
    
    console.log(`D√©filement slide-128 avant: ${slide128CurrentIndex} -> ${slide128CurrentIndex + 1}`);
    
    const tl = gsap.timeline({
      onComplete: () => {
        slide128CurrentIndex++;
        animationStates.value['slide-128-current-index'] = slide128CurrentIndex;
        isScrollingSlide128 = false;
        isNavigating.value = false;
        console.log(`D√©filement slide-128 termin√© - nouvel index: ${slide128CurrentIndex}`);
      }
    });
    
    // Gestion des classes actives
    if (currentItem) currentItem.classList.remove('active');
    if (nextItem) nextItem.classList.add('active');
    
    // Animation du content actuel vers le haut
    if (currentContent) {
      tl.to(currentContent, {
        autoAlpha: 0,
        y: -30,
        duration: 0.4,
        ease: 'power3.easeInOut'
      });
    }
    
    // Animation du nouveau content depuis le bas
    if (nextContent) {
      gsap.set(nextContent, { autoAlpha: 0, y: 30 });
      tl.to(nextContent, {
        autoAlpha: 1,
        y: 0,
        duration: 0.4,
        ease: 'power3.easeInOut'
      }, "-=0.2"); // Chevauchement pour plus de fluidit√©
    }

    return true; // Indiquer que l'animation a √©t√© lanc√©e
  };

  const scrollSlide128Backward = () => {
    if (isScrollingSlide128 || slide128CurrentIndex <= 0) return;
    
    isScrollingSlide128 = true;
    isNavigating.value = true;
    
    const slide128Section = sections.value.find(s => s.id === 'slide-128');
    const currentContent = slide128Section?.querySelector(`.case-study-content:nth-of-type(${slide128CurrentIndex + 1})`);
    const prevContent = slide128Section?.querySelector(`.case-study-content:nth-of-type(${slide128CurrentIndex})`);
    const currentItem = currentContent?.closest('.case-study-item');
    const prevItem = prevContent?.closest('.case-study-item');
    
    console.log(`D√©filement slide-128 arri√®re: ${slide128CurrentIndex} -> ${slide128CurrentIndex - 1}`);
    
    const tl = gsap.timeline({
      onComplete: () => {
        slide128CurrentIndex--;
        animationStates.value['slide-128-current-index'] = slide128CurrentIndex;
        isScrollingSlide128 = false;
        isNavigating.value = false;
        console.log(`D√©filement slide-128 arri√®re termin√© - nouvel index: ${slide128CurrentIndex}`);
      }
    });
    
    // Gestion des classes actives
    if (currentItem) currentItem.classList.remove('active');
    if (prevItem) prevItem.classList.add('active');
    
    // Animation du content actuel vers le bas
    if (currentContent) {
      tl.to(currentContent, {
        autoAlpha: 0,
        y: 30,
        duration: 0.4,
        ease: 'power3.easeInOut'
      });
    }
    
    // Animation du content pr√©c√©dent depuis le haut
    if (prevContent) {
      gsap.set(prevContent, { autoAlpha: 0, y: -30 });
      tl.to(prevContent, {
        autoAlpha: 1,
        y: 0,
        duration: 0.4,
        ease: 'power3.easeInOut'
      }, "-=0.2"); // Chevauchement pour plus de fluidit√©
    }

    return true; // Indiquer que l'animation a √©t√© lanc√©e
  };

  const resetSlide128Animation = () => {
    const slide128Section = sections.value.find(s => s.id === 'slide-128');
    const killerwuDiv = slide128Section?.querySelector('#killerwu');
    const caseStudyContents = slide128Section?.querySelectorAll('.case-study-content');
    const caseStudyItems = slide128Section?.querySelectorAll('.case-study-item');
    
    console.log('Reset slide-128 animation');
    
    if (killerwuDiv) {
      gsap.set(killerwuDiv, { autoAlpha: 0 });
    }
    
    // R√©initialiser tous les contents
    if (caseStudyContents) {
      caseStudyContents.forEach((content, index) => {
        if (index === 0) {
          // Premier content : visible
          gsap.set(content, { autoAlpha: 1, y: 0 });
        } else {
          // Autres contents : masqu√©s
          gsap.set(content, { autoAlpha: 0, y: 30 });
        }
      });
    }
    
    // R√©initialiser les classes actives
    if (caseStudyItems) {
      caseStudyItems.forEach((item, index) => {
        if (index === 0) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
    }
    
    // Reset des variables
    slide128CurrentIndex = 0;
    maxSlide128Index = 0;
    isScrollingSlide128 = false;
    animationStates.value['slide-128-initialized'] = false;
    animationStates.value['slide-128-current-index'] = 0;
  };

  // ===========================================================================
  // SECTION 5: INITIALISATION ET NETTOYAGE
  // ===========================================================================

  const init = (sectionsElements) => {
    if (!Array.isArray(sectionsElements) || sectionsElements.some(el => !(el instanceof HTMLElement))) {
      console.error('‚ùå Erreur: sectionsElements doit √™tre un tableau d\'√©l√©ments HTML');
      return;
    }

    sections.value = sectionsElements;

    if (sections.value.length > 0) {
      // Configuration des ScrollTriggers pour l'observation
      stObserve = ScrollTrigger.create({
        trigger: sections.value[0],
        start: "top center",
        end: "bottom center",
        scroller: SCROLLER_SELECTOR,
        onUpdate: (self) => {
          const progress = self.progress;
          const totalSections = sections.value.length;
          const newIndex = Math.min(Math.floor(progress * totalSections), totalSections - 1);
          
          if (newIndex !== currentSectionIndex.value && !isNavigating.value) {
            currentSectionIndex.value = newIndex;
          }
        }
      });

      // Enregistrement des animations sp√©cifiques
      registerSlide73Animation();
      registerSlide20Animation();
      registerSlide23Animation();
      registerSlide59Animation();
      registerSlide128Animation();

      // Configuration des √©v√©nements de navigation
      keyboardListener.value = (e) => handleKeyboardNavigation(e);
      document.addEventListener('keydown', keyboardListener.value);
      document.addEventListener('wheel', handleWheelEvent, { passive: false });

      // Navigation initiale
      goToSection(0, 0);
    }
  };

  const cleanup = () => {
    if (stObserve) {
      stObserve.kill();
      stObserve = null;
    }

    specificAnimationTriggers.forEach(st => st.kill());
    specificAnimationTriggers.length = 0;

    slideSpecificEventListeners.forEach(listener => {
      listener.element.removeEventListener(listener.event, listener.handler);
    });
    slideSpecificEventListeners.length = 0;

    if (keyboardListener.value) {
      document.removeEventListener('keydown', keyboardListener.value);
      keyboardListener.value = null;
    }

    document.removeEventListener('wheel', handleWheelEvent);

    gsap.killTweensOf(SCROLLER_SELECTOR);

    // Reset de tous les √©tats
    currentSectionIndex.value = 0;
    isNavigating.value = false;
    hasScrolledOnce.value = false;
    isAnimating.value = false;
    Object.keys(animationStates.value).forEach(key => delete animationStates.value[key]);
    sections.value = [];
  };

  onUnmounted(() => {
    cleanup();
  });

  // Fonctions de debug
  window.debugDesktopAnimations = {
    states: animationStates,
    resetSlide73: resetSlide73Animation,
    reverseSlide73: reverseSlide73Animation,
    resetSlide20: resetSlide20Animation,
    resetSlide23: resetSlide23Animation,
    resetSlide59: resetSlide59Animation,
    resetSlide128: resetSlide128Animation,
    triggerSlide73: triggerSlide73Animation,
    currentSection: () => sections.value[currentSectionIndex.value]?.id
  };

  return {
    currentSectionIndex,
    isNavigating,
    animationStates,
    init,
    goToSection,
    cleanup
  };
}

export default useFullpageScrollTrigger;